set_property(GLOBAL PROPERTY USE_FOLDERS ON)

# Remember the binary dir for later
set(EMBED_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/embed CACHE INTERNAL "binary directory of the battery::embed library" FORCE)

# The common battery::embed header and source files
set(EMBED_HEADER_FILE [=[
// File generated by battery::embed
// DO NOT EDIT THIS FILE!!!
#ifndef PIKA_BATTERY_EMBED_HPP
#define PIKA_BATTERY_EMBED_HPP

#include <vector>
#include <string>
#include <string_view>
#include <stdexcept>
#include <sstream>
#include <functional>
#include <cstdint>
#include <algorithm>

#ifndef __cpp_constexpr_dynamic_alloc
#   error "battery::embed requires C++20 (Your compiler does not provide __cpp_constexpr_dynamic_alloc, which is needed for battery::embed)"
#endif

namespace pika_emb {

    struct EmbedInternal {

        class EmbeddedFile {
        public:
            constexpr EmbeddedFile() = default;

            constexpr EmbeddedFile(
                    const std::string_view& data,
                    const std::string_view& filename
            )
                : m_data(data)
                , m_filename(filename)
            {}

            [[nodiscard]] std::string str() const {
                return m_data.data();
            }

            [[nodiscard]] const char* data() const {
                return m_data.data();
            }

            [[nodiscard]] std::vector<uint8_t> vec() const {
                return { m_data.begin(), m_data.end() };
            }

            [[nodiscard]] size_t length() const {
                return m_data.size();
            }

            [[nodiscard]] size_t size() const {
                return m_data.size();
            }

            operator std::string() const {
                return str();
            }

            operator std::vector<uint8_t>() const {
                return vec();
            }

        private:
            std::string_view m_data;
            std::string_view m_filename;
        }; // class EmbeddedFile

        ${EMBEDDED_FILES_DECLARATIONS}
    };   // struct embedded_files

    template<size_t N>
    struct embed_string_literal {
        constexpr embed_string_literal(const char (&str)[N]) {
            std::copy_n(str, N, value);
        }
        constexpr bool operator!=(const embed_string_literal& other) const {
            return std::equal(value, value + N, other.value);
        }
        [[nodiscard]] std::string str() const {
            return std::string(value, N);
        }
        [[nodiscard]] constexpr bool _false() const {
            return false;
        }
        char value[N];
    };

    template<size_t N, size_t M>
    constexpr bool operator==(const embed_string_literal<N>& left, const char (&right)[M]) {
        return std::equal(left.value, left.value + N, right);
    }

    template<embed_string_literal identifier>
    constexpr EmbedInternal::EmbeddedFile embed() {
        ${EMBEDDED_FILES_RETURNS}{
            static_assert(identifier._false(), "[pika_emb::embed<>] No such file or directory");
        }
    }

} // namespace pika_emb

inline std::ostream& operator<<(std::ostream& stream, const pika_emb::EmbedInternal::EmbeddedFile& file) {
    stream << file.str();
    return stream;
}

#endif // PIKA_BATTERY_EMBED_HPP
]=])
file(WRITE ${EMBED_BINARY_DIR}/pk_embed_header_file_template.hpp "${EMBED_HEADER_FILE}")

# The cmake script to embed the files. This is called later on-demand, in a separate process
set(EMBED_GENERATE_SCRIPT [=[
file(READ "${FULL_PATH}" GENERATED_BYTE_ARRAY HEX)
string(LENGTH "${GENERATED_BYTE_ARRAY}" FILESIZE)
math(EXPR FILESIZE "${FILESIZE} / 2")

string(REPEAT "[0-9a-f]" 32 PATTERN)
set(GENERATED_BYTE_ARRAY "\"${GENERATED_BYTE_ARRAY}")
string(REGEX REPLACE "${PATTERN}" "\\0\"\n            \"" GENERATED_BYTE_ARRAY ${GENERATED_BYTE_ARRAY})
string(REGEX REPLACE "([0-9a-f][0-9a-f])" "\\\\x\\1" GENERATED_BYTE_ARRAY ${GENERATED_BYTE_ARRAY})
set(GENERATED_BYTE_ARRAY "${GENERATED_BYTE_ARRAY}\"")
configure_file(${INFILE} ${OUTFILE})
]=])
file(WRITE ${EMBED_BINARY_DIR}/generate.cmake ${EMBED_GENERATE_SCRIPT})

set(EMBED_IDENTIFIERS "" CACHE INTERNAL "list of all identifiers used by battery::embed")
set(EMBED_FILENAMES "" CACHE INTERNAL "list of all filenames used by battery::embed")
set(EMBED_TARGETS "" CACHE INTERNAL "list of all targets used by battery::embed")

# Defer the function call until the end of the configure step
cmake_language(DEFER DIRECTORY ${CMAKE_SOURCE_DIR} CALL _embed_generate_all_hpps())
function(_embed_generate_all_hpps)
    message(STATUS "Generating pika_emb::embed() HPP files ...")
    foreach (TARGET ${EMBED_TARGETS})
        _embed_generate_hpp(${TARGET})
    endforeach()
    message(STATUS "Generating pika_emb::embed() HPP files ... Done")
endfunction(_embed_generate_all_hpps)

function(_embed_generate_hpp TARGET)
    string(TOLOWER "${TARGET}" TARGET)
    string(REGEX REPLACE "[^a-zA-Z0-9_]" "_" TARGET "${TARGET}")

    if (NOT EMBED_IDENTIFIERS)
        return()
    endif()
    set(EMBEDDED_FILES_DECLARATIONS "")
    list(LENGTH EMBED_IDENTIFIERS num_identifiers)
    foreach (IDENTIFIER IN LISTS EMBED_IDENTIFIERS)
        if (IDENTIFIER MATCHES "^${TARGET}_")
            set(EMBEDDED_FILES_DECLARATIONS "${EMBEDDED_FILES_DECLARATIONS}static EmbeddedFile ${IDENTIFIER};\n        ")
        endif()
    endforeach()
    set(EMBEDDED_FILES_RETURNS "")
    math(EXPR num_identifiers "${num_identifiers} - 1")
    foreach (INDEX RANGE ${num_identifiers})
        list(GET EMBED_IDENTIFIERS ${INDEX} IDENTIFIER)
        list(GET EMBED_FILENAMES ${INDEX} FILENAME)
        if (IDENTIFIER MATCHES "^${TARGET}_")
            set(EMBEDDED_FILES_RETURNS "${EMBEDDED_FILES_RETURNS}if constexpr (identifier == \"${FILENAME}\") { return EmbedInternal::${IDENTIFIER}; }\n        else ")
        endif()
    endforeach()
    file(READ ${EMBED_BINARY_DIR}/pk_embed_header_file_template.hpp EMBED_HEADER_FILE)
    string(CONFIGURE "${EMBED_HEADER_FILE}" EMBED_HEADER_FILE_GENERATED)
    set(EMBED_HPP "${EMBED_BINARY_DIR}/autogen/${TARGET}/include/battery/pk_embed.hpp")
    file(WRITE "${EMBED_HPP}" "${EMBED_HEADER_FILE_GENERATED}")
endfunction(_embed_generate_hpp)

# Internal function for validating an identifier
function(embed_validate_identifier IDENTIFIER)  # Validate the identifier against C variable naming rules
    if (NOT IDENTIFIER MATCHES "^[a-zA-Z_][a-zA-Z0-9_]*$")
        message(FATAL_ERROR "embed: Identifier contains invalid characters: '${IDENTIFIER}'")
    endif()
endfunction()

# The main function for embedding files
function(pika_embed TARGET FILENAME)
    string(TOLOWER "${TARGET}" TARGET_ID)
    string(REGEX REPLACE "[^a-zA-Z0-9_]" "_" TARGET_ID "${TARGET_ID}")

    if (IS_ABSOLUTE "${FILENAME}")
        message(FATAL_ERROR "embed: File name must be relative to the current source directory: '${FILENAME}'")
    endif()

    # Make the identifier
    string(TOLOWER "${TARGET_ID}_${FILENAME}" IDENTIFIER)
    string(REGEX REPLACE "[^a-zA-Z0-9_]" "_" IDENTIFIER "${IDENTIFIER}") # Replace all invalid characters with underscores
    embed_validate_identifier("${IDENTIFIER}") # Validate the identifier against C variable naming rules

    # Set up paths
    get_filename_component(FULL_PATH "${FILENAME}" ABSOLUTE) # Make the file path absolute
    set(CPP_FILE "${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/src/pk_${IDENTIFIER}.cpp")

    # If identifier already in use
    list(FIND EMBED_IDENTIFIERS ${IDENTIFIER} EMBED_USED_IDENTIFIERS_INDEX)
    if (NOT EMBED_USED_IDENTIFIERS_INDEX EQUAL -1)
        message(FATAL_ERROR "embed: Identifier already in use: '${IDENTIFIER}'")
    endif()
    set(EMBED_IDENTIFIERS ${EMBED_IDENTIFIERS} ${IDENTIFIER} CACHE INTERNAL "list of all identifiers used by the embed library")
    set(EMBED_FILENAMES ${EMBED_FILENAMES} ${FILENAME} CACHE INTERNAL "list of all filenames used by the embed library")
    set(EMBED_TARGETS ${EMBED_TARGETS} ${TARGET} CACHE INTERNAL "list of all targets used by the embed library")

    # This action generates both files and is called on-demand whenever the resource file changes
    set(EMBED_HPP "${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/include/battery/pk_embed.hpp")
    set(EMBED_CPP_TEMPLATE "${EMBED_BINARY_DIR}/pk_embed_source_file_template.cpp")
    add_custom_command(
            COMMAND ${CMAKE_COMMAND}
            -DINFILE=${EMBED_CPP_TEMPLATE}
            -DOUTFILE=${CPP_FILE}
            -DFULL_PATH=${FULL_PATH}
            -DIDENTIFIER=${IDENTIFIER}
            -DFILENAME=${FILENAME}
            -P "${EMBED_BINARY_DIR}/generate.cmake"
            DEPENDS "${FULL_PATH}" "${EMBED_HPP}" "${EMBED_BINARY_DIR}/generate.cmake" "${EMBED_BINARY_DIR}/pk_embed_source_file_template.cpp"
            OUTPUT ${CPP_FILE}
            VERBATIM
    )

    # Add the generated files to the target
    target_include_directories(${TARGET} PUBLIC ${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/include)
    target_sources(${TARGET} PRIVATE ${CPP_FILE} ${EMBED_HPP})
    target_compile_definitions(${TARGET} PRIVATE _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING)

    if (MSVC)
        target_sources(${TARGET} PRIVATE ${FULL_PATH})
        source_group(TREE ${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/src PREFIX "embed/autogen" FILES ${CPP_FILE})
        source_group(TREE ${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/include/battery PREFIX "embed/autogen" FILES ${EMBED_HPP})
        source_group(TREE "${CMAKE_CURRENT_SOURCE_DIR}" PREFIX "/embed" FILES ${FULL_PATH})
    endif()

endfunction()

function(pika_embed_proxy_target MAIN_TARGET PROXY_TARGET)
    add_library(${PROXY_TARGET} STATIC)
    target_compile_features(${PROXY_TARGET} PUBLIC cxx_std_20)
    target_link_libraries(${MAIN_TARGET} PRIVATE ${PROXY_TARGET})
    set_target_properties(${PROXY_TARGET} PROPERTIES FOLDER "embed-proxy-targets")
endfunction()
