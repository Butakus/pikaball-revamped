# Original Copyright 2024 Florian Zachs
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This is a modified version of the original battery::embed tool.
# Copyright 2025 Francisco Miguel Moreno
# The original software has been modified to remove unwanted features
# and to adapt the API to the Pikaball-Revamped project.

# Remember the binary dir for later
set(EMBED_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/embed CACHE INTERNAL "binary directory of the battery::embed library" FORCE)

# The template for how to generate the .cpp file
set(EMBED_SOURCE_FILE_TEMPLATE [==[
// File generated using battery::embed (https://github.com/batterycenter/embed)
// Embedded file: '${FILENAME}' as '${IDENTIFIER}'
// Filesize: ${FILESIZE} bytes
// DO NOT EDIT THIS FILE!!!

#include "battery/pika_embed.hpp"

namespace pika::b {

    EmbedInternal::EmbeddedFile EmbedInternal::${IDENTIFIER} = {
        std::string_view(
            ${GENERATED_BYTE_ARRAY},
            ${FILESIZE}
        )
        , "${FILENAME}"
    };

} // namespace pika::b
]==])
file(WRITE ${EMBED_BINARY_DIR}/pika_embed_source_file_template.cpp "${EMBED_SOURCE_FILE_TEMPLATE}")

# The common battery::embed header and source files
set(EMBED_HEADER_FILE [=[
// File generated by battery::embed
// DO NOT EDIT THIS FILE!!!
#ifndef PIKA_BATTERY_EMBED_HPP
#define PIKA_BATTERY_EMBED_HPP

#include <vector>
#include <string>
#include <string_view>
#include <cstdint>
#include <algorithm>

#ifndef __cpp_constexpr_dynamic_alloc
#   error "battery::embed requires C++20 (Your compiler does not provide __cpp_constexpr_dynamic_alloc, which is needed for battery::embed)"
#endif

namespace pika::b {

    struct EmbedInternal {

        class EmbeddedFile {
        public:
            constexpr EmbeddedFile() = default;

            constexpr EmbeddedFile(
                    const std::string_view& data,
                    const std::string_view& filename
            )
                : m_data(data)
                , m_filename(filename)
            {}

            [[nodiscard]] std::string str() const {
                return m_data.data();
            }

            [[nodiscard]] const char* data() const {
                return m_data.data();
            }

            [[nodiscard]] std::vector<uint8_t> vec() const {
                return { m_data.begin(), m_data.end() };
            }

            [[nodiscard]] size_t length() const {
                return m_data.size();
            }

            [[nodiscard]] size_t size() const {
                return m_data.size();
            }

            [[nodiscard]] std::string_view filename() const {
                return m_filename;
            }

            operator std::string() const {
                return str();
            }

            operator std::vector<uint8_t>() const {
                return vec();
            }

        private:
            std::string_view m_data;
            std::string_view m_filename;
        }; // class EmbeddedFile

        ${EMBEDDED_FILES_DECLARATIONS}
    };   // struct embedded_files

    template<size_t N>
    struct embed_string_literal {
        constexpr embed_string_literal(const char (&str)[N]) {
            std::copy_n(str, N, value);
        }
        constexpr bool operator!=(const embed_string_literal& other) const {
            return std::equal(value, value + N, other.value);
        }
        char value[N];
    };

    template<size_t N, size_t M>
    constexpr bool operator==(const embed_string_literal<N>& left, const char (&right)[M]) {
        return std::equal(left.value, left.value + N, right);
    }

    template<embed_string_literal identifier>
    constexpr EmbedInternal::EmbeddedFile embed() {
        ${EMBEDDED_FILES_RETURNS}{
            static_assert(false, "[pika::b::embed<>] No such file or directory");
        }
    }

} // namespace pika::b

#endif // PIKA_BATTERY_EMBED_HPP
]=])
file(WRITE ${EMBED_BINARY_DIR}/pika_embed_header_file_template.hpp "${EMBED_HEADER_FILE}")


set(EMBED_IDENTIFIERS "" CACHE INTERNAL "list of all identifiers used by battery::embed")
set(EMBED_FILENAMES "" CACHE INTERNAL "list of all filenames used by battery::embed")
set(EMBED_TARGETS "" CACHE INTERNAL "list of all targets used by battery::embed")

# Defer the function call until the end of the configure step
function(_embed_generate_all_hpps)
    message(STATUS "Generating pika::b::embed() HPP files ...")
    foreach (TARGET ${EMBED_TARGETS})
        _embed_generate_hpp(${TARGET})
    endforeach()
    message(STATUS "Generating pika::b::embed() HPP files ... Done")
endfunction(_embed_generate_all_hpps)

function(_embed_generate_hpp TARGET)
    string(TOLOWER "${TARGET}" TARGET)
    string(REGEX REPLACE "[^a-zA-Z0-9_]" "_" TARGET "${TARGET}")

    if (NOT EMBED_IDENTIFIERS)
        return()
    endif()
    set(EMBEDDED_FILES_DECLARATIONS "")
    list(LENGTH EMBED_IDENTIFIERS num_identifiers)
    foreach (IDENTIFIER IN LISTS EMBED_IDENTIFIERS)
        if (IDENTIFIER MATCHES "^${TARGET}_")
            set(EMBEDDED_FILES_DECLARATIONS "${EMBEDDED_FILES_DECLARATIONS}static EmbeddedFile ${IDENTIFIER};\n        ")
        endif()
    endforeach()
    set(EMBEDDED_FILES_RETURNS "")
    math(EXPR num_identifiers "${num_identifiers} - 1")
    foreach (INDEX RANGE ${num_identifiers})
        list(GET EMBED_IDENTIFIERS ${INDEX} IDENTIFIER)
        list(GET EMBED_FILENAMES ${INDEX} FILENAME)
        if (IDENTIFIER MATCHES "^${TARGET}_")
            set(EMBEDDED_FILES_RETURNS "${EMBEDDED_FILES_RETURNS}if constexpr (identifier == \"${FILENAME}\") { return EmbedInternal::${IDENTIFIER}; }\n        else ")
        endif()
    endforeach()
    file(READ ${EMBED_BINARY_DIR}/pika_embed_header_file_template.hpp EMBED_HEADER_FILE)
    string(CONFIGURE "${EMBED_HEADER_FILE}" EMBED_HEADER_FILE_GENERATED)
    set(EMBED_HPP "${EMBED_BINARY_DIR}/autogen/${TARGET}/include/battery/pika_embed.hpp")
    file(WRITE "${EMBED_HPP}" "${EMBED_HEADER_FILE_GENERATED}")
endfunction(_embed_generate_hpp)

# Internal function for validating an identifier
function(embed_validate_identifier IDENTIFIER)  # Validate the identifier against C variable naming rules
    if (NOT IDENTIFIER MATCHES "^[a-zA-Z_][a-zA-Z0-9_]*$")
        message(FATAL_ERROR "embed: Identifier contains invalid characters: '${IDENTIFIER}'")
    endif()
endfunction()

# Generate embedded source file at configure time.
function(embed_generate_configure)
    cmake_parse_arguments(EGC "" "INFILE;OUTFILE;ABS_PATH;IDENTIFIER;FILENAME" "" ${ARGN})

    if (NOT EGC_INFILE OR NOT EGC_OUTFILE OR NOT EGC_ABS_PATH OR NOT EGC_IDENTIFIER OR NOT EGC_FILENAME)
        message(FATAL_ERROR "embed_generate_configure: missing required args")
    endif()

    # Ensure output directory exists
    get_filename_component(_out_dir "${EGC_OUTFILE}" DIRECTORY)
    file(MAKE_DIRECTORY "${_out_dir}")

    message(STATUS "_out_dir '${_out_dir}'")

    # Read file bytes as hex and compute filesize
    file(READ "${EGC_ABS_PATH}" GENERATED_BYTE_ARRAY HEX)
    string(LENGTH "${GENERATED_BYTE_ARRAY}" _len)
    math(EXPR FILESIZE "${_len} / 2")

    # Build a quoted C string with \xNN escapes and readable line breaks
    string(REPEAT "[0-9a-f]" 32 PATTERN)
    set(GENERATED_BYTE_ARRAY "\"${GENERATED_BYTE_ARRAY}")
    string(REGEX REPLACE "${PATTERN}" "\\0\"\n            \"" GENERATED_BYTE_ARRAY ${GENERATED_BYTE_ARRAY})
    string(REGEX REPLACE "([0-9a-f][0-9a-f])" "\\\\x\\1" GENERATED_BYTE_ARRAY ${GENERATED_BYTE_ARRAY})
    set(GENERATED_BYTE_ARRAY "${GENERATED_BYTE_ARRAY}\"")

    # Make variables available for configure_file substitution and run configure
    set(FILESIZE "${FILESIZE}")
    set(IDENTIFIER "${EGC_IDENTIFIER}")
    set(FILENAME "${EGC_FILENAME}")

    configure_file("${EGC_INFILE}" "${EGC_OUTFILE}")
endfunction()

# The main function for embedding files
function(pika_embed TARGET)
    # Accept multiple resource paths in ARGN
    if (NOT ARGN)
        message(FATAL_ERROR "embed: pika_embed requires at least one filename")
    endif()

    string(TOLOWER "${TARGET}" TARGET_ID)
    string(REGEX REPLACE "[^a-zA-Z0-9_]" "_" TARGET_ID "${TARGET_ID}")

    # Prepare some variables used for generation
    set(EMBED_HPP "${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/include/battery/pika_embed.hpp")
    set(EMBED_CPP_TEMPLATE "${EMBED_BINARY_DIR}/pika_embed_source_file_template.cpp")
    file(MAKE_DIRECTORY "${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/include/battery")
    file(MAKE_DIRECTORY "${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/src")

    set(GENERATED_CPPS "")

    foreach(FILENAME IN LISTS ARGN)
        message(STATUS "Embedding file '${FILENAME}'")

        # Derive a filename to record in the header and to base the identifier on.
        # Prefer a path relative to the source dir when possible, otherwise fall back to the basename.
        file(RELATIVE_PATH _REL_PATH "${CMAKE_SOURCE_DIR}" "${FILENAME}")
        message(STATUS "RELATIVE_PATH '${_REL_PATH}'")

        # Make the identifier from the target id + recorded filename
        string(TOLOWER "${TARGET_ID}_${_REL_PATH}" IDENTIFIER)
        string(REGEX REPLACE "[^a-zA-Z0-9_]" "_" IDENTIFIER "${IDENTIFIER}")
        embed_validate_identifier("${IDENTIFIER}")
        message(STATUS "Validated IDENTIFIER '${IDENTIFIER}'")

        set(CPP_FILE "${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/src/pika_${IDENTIFIER}.cpp")
        message(STATUS "CPP_FILE '${CPP_FILE}'")

        # If identifier already in use
        list(FIND EMBED_IDENTIFIERS ${IDENTIFIER} EMBED_USED_IDENTIFIERS_INDEX)
        if (NOT EMBED_USED_IDENTIFIERS_INDEX EQUAL -1)
            message(FATAL_ERROR "embed: Identifier already in use: '${IDENTIFIER}'")
        endif()

        # Record identifier/filename and the target owning them (use _REL_PATH for header)
        set(EMBED_IDENTIFIERS ${EMBED_IDENTIFIERS} ${IDENTIFIER} CACHE INTERNAL "list of all identifiers used by the embed library")
        set(EMBED_FILENAMES ${EMBED_FILENAMES} ${_REL_PATH} CACHE INTERNAL "list of all filenames used by the embed library")
        set(EMBED_TARGETS ${EMBED_TARGETS} ${TARGET} CACHE INTERNAL "list of all targets used by the embed library")
        message(STATUS "EMBED_IDENTIFIERS '${EMBED_IDENTIFIERS}'")
        message(STATUS "EMBED_FILENAMES '${EMBED_FILENAMES}'")
        message(STATUS "EMBED_TARGETS '${EMBED_TARGETS}'")

        # Generate the source file now during configure for this resource
        embed_generate_configure(
            INFILE "${EMBED_CPP_TEMPLATE}"
            OUTFILE "${CPP_FILE}"
            ABS_PATH "${FILENAME}"
            IDENTIFIER "${IDENTIFIER}"
            FILENAME "${_REL_PATH}"
        )

        list(APPEND GENERATED_CPPS "${CPP_FILE}")
    endforeach()
    message(STATUS "GENERATED_CPPS '${GENERATED_CPPS}'")

    # Generate header files
    _embed_generate_all_hpps()

    # Add the generated files to the target (all at once)
    target_include_directories(${TARGET} PUBLIC ${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/include)
    target_sources(${TARGET} PRIVATE ${GENERATED_CPPS} ${EMBED_HPP})
    target_compile_definitions(${TARGET} PRIVATE _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING)

    if (MSVC)
        # Expose original files and autogen sources in IDE
        foreach(CPP_FILE IN LISTS GENERATED_CPPS)
            source_group(TREE ${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/src PREFIX "embed/autogen" FILES ${CPP_FILE})
        endforeach()
        source_group(TREE ${EMBED_BINARY_DIR}/autogen/${TARGET_ID}/include/battery PREFIX "embed/autogen" FILES ${EMBED_HPP})
        foreach(FILENAME IN LISTS ARGN)
            get_filename_component(FULL_PATH_MSCV "${FILENAME}" ABSOLUTE)
            source_group(TREE "${CMAKE_CURRENT_SOURCE_DIR}" PREFIX "/embed" FILES ${FULL_PATH_MSCV})
        endforeach()
    endif()

endfunction()
